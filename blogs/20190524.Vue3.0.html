<small>最后编辑于2019-05-09</small>

# Composition API

##
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Composition Functions —— Vue 3.0</title>
  <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  <h1>Composition Functions</h1>
  <hr>
  <ul>
    <li>value</li>
    <li>watch</li>
    <li>computed</li>
    <li>inject</li>
    <li>onMounted(lifecycle hooks)</li>
  </ul>
  <p><a href="https://github.com/vuejs/rfcs/pull/17?utm_source=wechat_session&utm_medium=social&utm_oi=827666025876197376" target="blank">Issue</a>中给出的例子：</p>
  <pre>
    // everything tree-shakable
    import {
      value,
      computed,
      watch,
      onMounted,
      inject
    } from 'vue'

    const App = {
      // same as before
      props: {
        a: String,
        b: Number
      },

      // same as before
      components: {
        // ...
      },

      setup(props) {
        // data
        const count = value(1)

        // computed
        const plusOne = computed(() => count.value + 1)

        // methods
        function inc() {
          count.value++
        }

        // watch
        watch(() => props.b + count.value, val => {
          console.log('changed: ', val)
        })

        // lifecycle
        onMounted(() => {
          console.log('mounted!')
        })

        // dependency injection
        const injected = inject(SomeSymbol)

        // other options like el, extends and mixins are no longer necessary

        // expose bindings on render context
        // any value containers will be unwrapped when exposed
        // any non-containers will be exposed as-is, including functions
        return {
          count,
          plusOne,
          inc,
          injected
        }
      },

      // template: `same as before`,

      render({ state, props, slots }) {
        // `this` points to the render context and works same as before (exposes everything)
        // `state` exposes bindings returned from `setup()` (with value wrappers unwrapped)
      }
    }
  </pre>
  <p>基于Vue响应式系统的依赖收集方式，声明一个跨组件的依赖（数据）是非常自然的，一个依赖天然地可以和组件解耦，使用value函数便可以在一个单独的模块中声明一个依赖以及其对应的可复用逻辑，在不考虑Time Travel的情况下可以简单地代替全局状态管理，虽然用法与React Hooks相似，但其内部实现必然是完全不同的，原因便是Vue组件基于Watcher而不是基于本身无状态的组件函数，因此也不会有hooks那样不允许放在条件语句中的限制。</p>
  <p>正如评论中所提到的<q>always take composition over inheritance</q>，继承的沙盒特性导致不能灵活地定义一个组件的逻辑，而组合就没有这样的困扰，无论是mixin还是extend，在一个应用开发的过程中都远没有直接组合各个逻辑函数来的方便与清晰，且由于语义更为清晰的setup函数，因此this指针也变得不再那么莫名其妙。</p>
  <p>举个例子：有多个组件依赖一个跨组件的count状态以及对其进行操作的一组可复用逻辑。</p>
  <pre>
    // count.js
    import { value } from 'vue'
    export const count = value(0);
    export function inc() {
      count.value++;
    }
    export function dec() {
      count.value--;
    }
    export function reset() {
      count.value = 0;
    }

    // counter.js 
    import { createComponent } from 'vue'
    import { count, inc, dec } from 'count.js'
    const Inc = createComponent({
      setup() {
        return {
          count,
          inc,
        }
      },
      template: `&lt;button @click="inc"&gt;Click to increment: {{ count }}&lt;/button&gt;`
    })
    const Dec = createComponent({
      setup() {
        return {
          count,
          dec,
        }
      },
      template: `&lt;button @click="dec"&gt;Click to decrement: {{ count }}&lt;/button&gt;`
    })
  </pre>
  <p>上例中，组件Dec与Inc共享了一个count状态，没有任何多余的代码，直接用setup函数按照语义组装到组件中便可以使用，且所有逻辑都是可复用的，仅需一次声明。</p>
  <p>当然，除了声明与状态耦合的可复用逻辑，也完全可以模拟方法装饰器来声明与状态解耦的可复用逻辑。例如，当需要给一个方法增加一个执行时loading的逻辑时：</p>
  <pre>
    // Loading.js
    function async Loading(loading, method) {
      return function () {
        loading.value = true;
        await method.apply(this, arguments);
        loading.value = false;
      }
    }

    // loading-button.js
    import { createComponent } from 'vue'
    import { value } from 'vue'
    const LoadingButton = createComponent({
      template: `&lt;button :class="{ loading: loading }" @click="fetchSomething"&gt;submit&lt;/button&gt;`,
      setup() {
        const loading = value(false);
        function async fetchSomething() {
          // do sth async...
        }
        return {
          fetchSomething: Loading(loading, fetchSomething)
        }
      }
    })
  </pre>
  <p>利用这种方法也省去了装饰器语法不稳定的困扰。</p>
  <p>为了setup函数的干净整洁，也完全可以将组件的methods写在组件声明之外，仅需将操作的状态作为函数参数传入即可。</p>
</body>
</html>