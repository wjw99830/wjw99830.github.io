<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>自定义滚动条</title>
  <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  <h1>制作自定义滚动条</h1>
  <hr>
  <ul>
    <li>Vue</li>
  </ul>
  <p>滚动条隐藏的方案参照Element UI的文档里的滚动条，设置margin-bottom和margin-right为-17px以使元素偏移一个滚动条的位置，同时将overflow设置为scroll</p>
  <p>起初的思路是写成一个vue指令来强化一个组件的dom元素，但是考虑到滚动条隐藏的方案需要一个视觉上隐形的容器来配合，因此改为编写一个vue组件，slot为滚动内容，在容器中增加2个子元素分别作为x和y轴的滚动条，提供一个color属性设置滚动条的颜色，默认hover时透明度为0.5。</p>
  <p>具体的模拟滚动思路是将插槽设置为<span class="inline-code">overflow：scroll</span>，由于插槽不支持属性继承，因此需要使用ref通过addEventListener为其添加scroll事件监听，这里的操作dom的时机需要考虑到插槽内size的动态变化，因此监听容器的mousemove事件，实时计算插槽的尺寸以修改滚动条的长度，滚动条的移动采用transform实现，高频率更新下的性能比定位方式更好，计算位移时需要不断根据滚动的高度或鼠标拖动的长度来得到结果，计算时需要考虑最大与最小位移</p>
  <p><span class="modify">2019-06-13 12:07</span>在使用中发现，使用负外边距的方式来隐藏滚动条会在高度或宽度设置为100%时出现bug，由于宽高定死，滚动条变成inside形式显示在视图中，因此使用另一种方式隐藏滚动条：主动为内容设置宽高，都为100% + 17px，并且设置其scrollbar伪元素的宽高为17px，同时背景色为透明，以防万一。</p>
  <h1>TODO</h1>
  <hr>
  <ul>
    <li>暴露更多属性来定制样式</li>
    <li>大量使用实时计算的dom属性，需要进行性能调优</li>
    <li>当鼠标的x和y坐标超出滚动内容的矩形框时，应停止滚动，目前会在超出矩形框时仍然滚动，与原生滚动条行为不一致，略微影响体验</li>
  </ul>
</body>
</html>